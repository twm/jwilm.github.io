<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Name</title>
  <subtitle>Blog subtitle</subtitle>
  <id>http://blog.url.com/</id>
  <link href="http://blog.url.com/"/>
  <link href="http://blog.url.com/feed.xml" rel="self"/>
  <updated>2017-01-05T16:00:00-08:00</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>Announcing Alacritty, a GPU-accelerated terminal emulator</title>
    <link rel="alternate" href="http://blog.url.com/announcing-alacritty/"/>
    <id>http://blog.url.com/announcing-alacritty/</id>
    <published>2017-01-05T16:00:00-08:00</published>
    <updated>2017-01-06T20:47:50-08:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a href="https://github.com/jwilm/alacritty"&gt;Alacritty&lt;/a&gt; is a blazing fast, GPU accelerated terminal emulator. It&amp;rsquo;s written
in Rust and uses OpenGL for rendering to be the fastest terminal emulator
available. &lt;a href="https://github.com/jwilm/alacritty"&gt;Alacritty&lt;/a&gt; is available on GitHub in source form.&lt;/p&gt;

&lt;p&gt;&lt;img width="743" alt="Alacritty Screenshot" src="https://cloud.githubusercontent.com/assets/4285147/21690874/19037262-d32b-11e6-9c18-706b1f979eb7.png"&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p align="center"&gt;
  &lt;em&gt;Alacritty running vim inside tmux&lt;/em&gt;
&lt;/p&gt;

&lt;h1 id="alacritty"&gt;Alacritty&lt;/h1&gt;

&lt;p&gt;The rest of this post discusses what &lt;a href="https://github.com/jwilm/alacritty"&gt;Alacritty&lt;/a&gt; is, why it was built, who it&amp;rsquo;s
targeted at, and some architectural decisions that have enabled its unparalleled
performance. I&amp;rsquo;ll be giving a technical talk at the January 2017 &lt;a href="https://www.meetup.com/Rust-Bay-Area/events/236668916/"&gt;Rust Meetup in
SF&lt;/a&gt; if you want to learn more.&lt;/p&gt;

&lt;h2 id="about-the-project"&gt;About the project&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/jwilm/alacritty"&gt;Alacritty&lt;/a&gt; is the result of frustration with existing terminal emulators.
Using &lt;code&gt;vim&lt;/code&gt; inside &lt;code&gt;tmux&lt;/code&gt; in many terminals was a particularly bad experience.
None of them were ever quite fast enough. Even so, Linux does have some decent
alternatives. For example, &lt;code&gt;urxvt&lt;/code&gt; and &lt;code&gt;st&lt;/code&gt; give good experiences. The major
downside with those options is difficulty of configuration and inability to run
on non-X11 platforms. The options for macOS are particularly slow&amp;ndash;especially
with a full-screen terminal on a 4k monitor. None of these terminals are
cross-platform&amp;ndash;they are usually married to the windowing and font rendering
APIs of their native platform.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/jwilm/alacritty"&gt;Alacritty&lt;/a&gt; aims to address these issues. The project&amp;rsquo;s architecture and features
are guided by a set of values:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Correctness:&lt;/strong&gt; Alacritty should be able to properly render modern terminal
applications like &lt;code&gt;tmux&lt;/code&gt; and &lt;code&gt;vim&lt;/code&gt;. Glyphs should be rendered properly, and
the proper glyphs should be displayed.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Performance:&lt;/strong&gt; Alacritty should be the fastest terminal emulator available
anywhere.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Appearance:&lt;/strong&gt; Alacritty should have beautiful font rendering and look
fantastic on all supported platforms.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Simplicity:&lt;/strong&gt; Alacritty should be conservative about which features it
offers. As we&amp;rsquo;ve learned from past terminal emulators, it&amp;rsquo;s far too easy to
become bloated. &lt;code&gt;st&lt;/code&gt; taught us that it doesn&amp;rsquo;t need to be that way. Features
like GUI-based configuration, tabs and scrollback are unnecessary. The latter
features are better provided by a terminal multiplexer like &lt;code&gt;tmux&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Portability:&lt;/strong&gt; Alacritty should support major operating systems including
Linux, macOS, and Windows.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="initial-features"&gt;Initial Features&lt;/h2&gt;

&lt;p&gt;Many programs work correctly and without issue. &lt;code&gt;vim&lt;/code&gt;, &lt;code&gt;tmux&lt;/code&gt;, &lt;code&gt;htop&lt;/code&gt;, various
pagers and many other full-screen applications are rendered properly.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/jwilm/alacritty"&gt;Alacritty&lt;/a&gt; is incredibly fast. Compare &lt;code&gt;find /usr&lt;/code&gt; or equivalent with
your favorite terminal emulator. Keep in mind that command will be faster the
second time it&amp;rsquo;s run due to OS caching. Alacritty&amp;rsquo;s performance scales well with
screen size. Running at larger resolutions will tip the scale further in
Alacritty&amp;rsquo;s favor.&lt;/p&gt;

&lt;p&gt;Alacritty&amp;rsquo;s font rendering is great. Native font rasterization libraries are
used on each platform, and sub-pixel anti-aliasing is supported on both macOS
and Linux.&lt;/p&gt;

&lt;p&gt;macOS and Linux are supported in this pre-alpha release. Windows is not yet part
of the list, but the initial offering demonstrates making a cross-platform
terminal emulator is possible.&lt;/p&gt;

&lt;p&gt;Being a pre-alpha release, there is still pending work in key areas&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Less common applications have rendering issues&lt;/li&gt;
&lt;li&gt;A small subset of systems have performance issues with the OpenGL renderer&lt;/li&gt;
&lt;li&gt;Font rendering on macOS is not as good as the competition&lt;/li&gt;
&lt;li&gt;Wayland is not natively supported&lt;/li&gt;
&lt;li&gt;Fallback fonts are not supported&lt;/li&gt;
&lt;li&gt;Full-screen mode is not supported on Linux&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Such issues will be resolved prior to a 1.0 release. Many of them will be
resolved far earlier.&lt;/p&gt;

&lt;h1 id="what-makes-alacritty-fast"&gt;What makes Alacritty fast&lt;/h1&gt;

&lt;p&gt;&lt;a href="https://github.com/jwilm/alacritty"&gt;Alacritty&lt;/a&gt;&amp;rsquo;s biggest claim is that it&amp;rsquo;s the fastest terminal emulator
available.  If there&amp;rsquo;s a case where it&amp;rsquo;s not, then it&amp;rsquo;s either a bug in
Alacritty or a misconfigured system. Alacritty is fast for two reasons&amp;ndash;the
OpenGL renderer and the high throughput parser.&lt;/p&gt;

&lt;h2 id="opengl-rendering"&gt;OpenGL Rendering&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/jwilm/alacritty"&gt;Alacritty&lt;/a&gt;&amp;rsquo;s renderer is capable of doing ~500 FPS with a large screen
full of text. This is made possible by efficient OpenGL usage. State changes are
minimized as much as possible. Glyphs are rasterized only once and stored in a
texture atlas. Instance data for glyphs is uploaded once per frame, and the
screen is rendered in only two draw calls.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/jwilm/alacritty"&gt;Alacritty&lt;/a&gt; isn&amp;rsquo;t concerned with trying to only redraw what&amp;rsquo;s necessary. The
entire screen is redrawn each frame because it&amp;rsquo;s so cheap.&lt;/p&gt;

&lt;p&gt;Nominally, Alacritty will draw a new frame whenever the terminal state changes,
and only when the state changes. Alacritty will simply sit idle when there&amp;rsquo;s no
new data from the pseudoterminal or input events from the users. This helps
significantly with battery life.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/jwilm/alacritty"&gt;Alacritty&lt;/a&gt; is very good at processing huge amounts of text. Say that a user
wants to &lt;code&gt;cat 1gb_file.txt&lt;/code&gt;. There&amp;rsquo;s a lot of work for the parser to do. If
Alacritty were drawing frames constantly on every change, it would take a long
time to finish parsing and rendering the contents. Thankfully, V-Sync can help
here.&lt;/p&gt;

&lt;p&gt;V-Sync limits the frames drawn by Alacritty up to the monitor&amp;rsquo;s refresh
rate. 60Hz is a typical value here. Using this number, there are 16.7ms
available per frame. 2ms of that budget is occupied by the renderer, and the
remaining 14.7ms are available to the parser to process that huge stream of
text. Any text that is added to the terminal and scrolled past between frames
will never be drawn. This is a &lt;strong&gt;huge&lt;/strong&gt; performance win! The parser can process
many MBs of data between frames, and the user will still see text drawn very
smoothly.&lt;/p&gt;

&lt;h2 id="the-parser"&gt;The Parser&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/jwilm/alacritty"&gt;Alacritty&lt;/a&gt;&amp;rsquo;s performance is enhanced by having a good parser. Rust helped
significantly with this by enabling us to write small testable components and
combine them without overhead.&lt;/p&gt;

&lt;h3 id="zero-cost-abstractions"&gt;Zero-cost abstractions&lt;/h3&gt;

&lt;p&gt;Rust&amp;rsquo;s zero-cost abstractions enable building nicely abstracted components and
later combining them as if they were hand-written as one initially.&lt;/p&gt;

&lt;p&gt;The parser has an &lt;code&gt;advance()&lt;/code&gt; method which advances the state and sometimes
dispatches actions to the generic &lt;code&gt;Perform&lt;/code&gt; argument. Here&amp;rsquo;s the signature:&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;P&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Perform&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;performer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;P&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;byte&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;u8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whenever a byte arrives from the pseudoterminal, it is passed to this advance
method. Some bytes will cause state to accumulate in the parser; other bytes
will trigger an action. Actions might be something like printing a character to
the screen or executing an escape sequence. These actions are defined on a
&lt;code&gt;Perform&lt;/code&gt; trait which is passed to &lt;code&gt;advance()&lt;/code&gt;. For example, here&amp;rsquo;s the first
couple of methods on the trait:&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;/// Performs actions requested by the Parser&lt;/span&gt;
&lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="n"&gt;Perform&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;/// Draw a character to the screen&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;char&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c"&gt;/// Execute a C0 or C1 control function&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;execute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;byte&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;u8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c"&gt;// ..&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To see how this turns into a zero-cost abstraction, let&amp;rsquo;s look at where the
&lt;code&gt;Perform&lt;/code&gt; methods are actually called:&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nn"&gt;Action&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Print&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;performer&lt;/span&gt;&lt;span class="nf"&gt;.print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;byte&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nb"&gt;char&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="nn"&gt;Action&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Execute&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;performer&lt;/span&gt;&lt;span class="nf"&gt;.execute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;byte&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="c"&gt;// ..&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assuming the concrete &lt;code&gt;Perform&lt;/code&gt; type requests &lt;code&gt;#[inline]&lt;/code&gt; on these methods, they
will likely be inlined at the call site here and avoid function call overhead.&lt;/p&gt;

&lt;p&gt;This same pattern is used for multiple layers of abstraction. &lt;a href="https://github.com/jwilm/alacritty"&gt;Alacritty&lt;/a&gt;&amp;rsquo;s
&lt;code&gt;vte::Perform&lt;/code&gt; impl actually delegates to an &lt;code&gt;ansi::Handler&lt;/code&gt; type for actions
which requires additional parsing (eg. &lt;code&gt;csi_dispatch()&lt;/code&gt;).  The result is that we
get nice abstractions for things like &lt;code&gt;vte::Perform&lt;/code&gt; and &lt;code&gt;ansi::Handler&lt;/code&gt;, and
the parsing code compiles into what looks like a big hand-written state machine.&lt;/p&gt;

&lt;h3 id="table-driven-parsing"&gt;Table-driven parsing&lt;/h3&gt;

&lt;p&gt;Both the &lt;a href="https://docs.rs/utf8parse"&gt;utf8parse&lt;/a&gt; and &lt;a href="https://docs.rs/vte"&gt;vte&lt;/a&gt; crates that were written for &lt;a href="https://github.com/jwilm/alacritty"&gt;Alacritty&lt;/a&gt; use
table-driven parsers. The cool thing about these is that they have &lt;em&gt;very&lt;/em&gt; little
branching; &lt;a href="https://docs.rs/utf8parse"&gt;utf8parse&lt;/a&gt; only has &lt;a href="https://github.com/jwilm/vte/blob/b016827f471041320996f3273b4e3058501d7edf/utf8parse/src/lib.rs#L61"&gt;one branch&lt;/a&gt; in the entire
library!&lt;/p&gt;

&lt;p&gt;The transition tables for both &lt;code&gt;vte&lt;/code&gt; and &lt;code&gt;utf8parse&lt;/code&gt; are written using a
procedural macro. The macro translates a &lt;a href="https://github.com/jwilm/vte/blob/master/src/table.rs.in"&gt;high-level definition&lt;/a&gt; of the state
machine transitions to &lt;a href="https://github.com/jwilm/vte/blob/master/src/table.rs"&gt;low-level lookup tables&lt;/a&gt;. That is, the state machine can
be described like this:&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// Transition tables description. Much was omitted for brevity.&lt;/span&gt;
&lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;STATE_CHANGE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nb"&gt;u8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nd"&gt;vt_state_table!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nn"&gt;State&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Anywhere&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="mi"&gt;0x80&lt;/span&gt;...&lt;span class="mi"&gt;0x8f&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nn"&gt;Action&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Execute&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;State&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Ground&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="mi"&gt;0x9b&lt;/span&gt;        &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nn"&gt;State&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;CsiEntry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="nn"&gt;State&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Ground&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="mi"&gt;0x00&lt;/span&gt;...&lt;span class="mi"&gt;0x17&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nn"&gt;Action&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Execute&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="mi"&gt;0x20&lt;/span&gt;...&lt;span class="mi"&gt;0x7f&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nn"&gt;Action&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Print&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="mi"&gt;0xf0&lt;/span&gt;...&lt;span class="mi"&gt;0xf4&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nn"&gt;State&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Utf8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;Action&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;BeginUtf8&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="nn"&gt;State&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Escape&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="mi"&gt;0x00&lt;/span&gt;...&lt;span class="mi"&gt;0x17&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nn"&gt;Action&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Execute&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="mi"&gt;0x30&lt;/span&gt;...&lt;span class="mi"&gt;0x4f&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nn"&gt;Action&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;EscDispatch&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;State&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Ground&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="mi"&gt;0x58&lt;/span&gt;        &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nn"&gt;State&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;SosPmApcString&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output of the procedural macro is the transition tables:&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// Transition tables&lt;/span&gt;
&lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;STATE_CHANGE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nb"&gt;u8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;
        &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;92u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;92u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="c"&gt;// ..&lt;/span&gt;
    &lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="c"&gt;// ..&lt;/span&gt;
&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whenever a byte arrives, the parser looks up the table for the &lt;em&gt;current&lt;/em&gt; state
and indexes with that byte. The value returned contains the &lt;em&gt;next&lt;/em&gt; state and any
action required to make that transition. This process doesn&amp;rsquo;t requires
branching&amp;ndash;it&amp;rsquo;s a simple, fast lookup.&lt;/p&gt;

&lt;h1 id="new-libraries"&gt;New libraries&lt;/h1&gt;

&lt;p&gt;Developing &lt;a href="https://github.com/jwilm/alacritty"&gt;Alacritty&lt;/a&gt; required several pieces of library infrastructure which
were not available. A non-GPL licensed cross-platform clipboard library, a &lt;code&gt;vte&lt;/code&gt;
parser, cross-platform font rasterization and &lt;code&gt;fontconfig&lt;/code&gt; bindings were all
needed to build this project. &lt;a href="https://docs.rs/vte"&gt;vte&lt;/a&gt; and &lt;a href="https://docs.rs/utf8parse"&gt;utf8parse&lt;/a&gt; have been published on
&lt;a href="https://crates.io"&gt;crates.io&lt;/a&gt;. The remaining libraries are still in &lt;a href="https://github.com/jwilm/alacritty"&gt;Alacritty&lt;/a&gt;&amp;rsquo;s source tree and
will be published independently at some point.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a quick run-down of the new libraries:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/jwilm/alacritty/tree/master/copypasta"&gt;copypasta&lt;/a&gt;: Cross-platform clipboard access library&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/jwilm/alacritty/tree/master/font"&gt;font&lt;/a&gt;: Cross-platform font rasterization library&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.rs/utf8parse"&gt;utf8parse&lt;/a&gt;: A table-driven UTF-8 parser&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.rs/vte"&gt;vte&lt;/a&gt;: A table-driven terminal protocol parser&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/jwilm/alacritty/tree/master/ffi-util"&gt;ffi-util&lt;/a&gt;: Utilities for simplifying wrapping FFI types. This project is
from &lt;a href="https://github.com/sfackler"&gt;@sfackler&lt;/a&gt;&amp;rsquo;s &lt;a href="https://github.com/sfackler/rust-openssl"&gt;rust-openssl&lt;/a&gt; that I&amp;rsquo;ve put into a module
for wrapping &lt;code&gt;fontconfig&lt;/code&gt; C types.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id="conclusion"&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;&lt;a href="https://github.com/jwilm/alacritty"&gt;Alacritty&lt;/a&gt; is a very fast and usable terminal emulator. Although this is a
pre-alpha release, it works well enough for many developers to be used as a
daily driver. I&amp;rsquo;ve personally been using it as my primary terminal for a few
months now.&lt;/p&gt;

&lt;p&gt;For those wanting to learn more about the project, I&amp;rsquo;ll be giving a talk about
Alacritty at the upcoming &lt;a href="https://www.meetup.com/Rust-Bay-Area/events/236668916/"&gt;Rust Meetup in SF&lt;/a&gt; on January 19, 2017. I&amp;rsquo;m also
planning some more technical blog posts about various subsystems of Alacritty.&lt;/p&gt;

&lt;p&gt;This post has been discussed in several threads on Reddit and on Hacker News:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://news.ycombinator.com/item?id=13338592"&gt;Hacker News 1/6/2017&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.reddit.com/r/rust/comments/5mf2yh/announcing_alacritty_a_gpuaccelerated_terminal/"&gt;/r/rust 1/6/2017&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.reddit.com/r/programming/comments/5mflek/alacritty_a_gpuaccelerated_terminal_emulator/"&gt;/r/programming 1/6/2017&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.reddit.com/r/rust/comments/5m20al/github_jwilmalacritty_a_crossplatform_gpu/"&gt;/r/rust 1/4/2017&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href="https://twitter.com/i_am_jwilm"&gt;Follow me on Twitter&lt;/a&gt; if you&amp;rsquo;d like
to be notified about subsequent Alacritty releases and blog posts.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/jwilm/alacritty"&gt;Alacritty&lt;/a&gt;&amp;rsquo;s source is available on GitHub. Try it out for yourself!&lt;/p&gt;

&lt;!--
Other stuff that would be fun to talk about:

- The grid container and its index types
- Texture atlases
- Config loading
- Ref tests
- VTE state table definitions

--&gt;
</content>
  </entry>
  <entry>
    <title>From &amp;str to Cow</title>
    <link rel="alternate" href="http://blog.url.com/from-str-to-cow/"/>
    <id>http://blog.url.com/from-str-to-cow/</id>
    <published>2016-04-15T17:00:00-07:00</published>
    <updated>2016-05-05T08:08:42-07:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;Some of the first Rust code I wrote was a struct with a &lt;code&gt;&amp;amp;str&lt;/code&gt; field. As you
might imagine, the borrow checker didn&amp;rsquo;t let me do a lot of things, and the API
ergonomics were limited. This article aims to demonstrate the issues with having
raw &lt;code&gt;&amp;amp;str&lt;/code&gt; references in structs, introduce some intermediate APIs that
alleviate the ergonomics but aren&amp;rsquo;t necessarily efficient, and end with an
implementation that is both ergonomic and efficient.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say we&amp;rsquo;re making a library for the &lt;em&gt;example.com&lt;/em&gt; API. Each API call must
be authenticated with a token. A token definition might look like this:&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;/// Token for example.io API&lt;/span&gt;
&lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Token&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And maybe there&amp;rsquo;s an impl for creating a token given a &lt;code&gt;&amp;amp;str&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;impl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Token&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Token&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Token&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This &lt;code&gt;Token&lt;/code&gt; impl works really well for &lt;code&gt;&amp;amp;&amp;#39;static str&lt;/code&gt;. However, what if a user
doesn&amp;rsquo;t want to embed their authentication secret in the binary? Maybe the
secret is loaded from a vault at run time. We might want to write some code like
this.&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;/// Imagine that this function exists&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;secret&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;secret_from_vault&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"api.example.io"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Token&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;secret&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;..&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This implementation has a big limitation; &lt;code&gt;token&lt;/code&gt; cannot outlive &lt;code&gt;secret&lt;/code&gt;, and
that means &lt;code&gt;token&lt;/code&gt; can&amp;rsquo;t escape this stack frame. What if &lt;code&gt;Token&lt;/code&gt; just held a
&lt;code&gt;String&lt;/code&gt;? That would get rid of the lifetime parameter making &lt;code&gt;Token&lt;/code&gt; a purely
owned type.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Token&lt;/code&gt; and its &lt;code&gt;new&lt;/code&gt; function look like this after making the change.&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Token&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Token&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Token&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Token&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The use case where a String is provided has been fixed.&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// this works now&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Token&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;secret_from_vault&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"api.example.io"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, this has actively harmed the usability of providing a &lt;code&gt;&amp;amp;&amp;#39;str&lt;/code&gt;. For
example, this won&amp;rsquo;t compile:&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// doesn't compile&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Token&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"abc123"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The consumer of this API would need to manually convert that into a &lt;code&gt;String&lt;/code&gt;
first.&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Token&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"abc123"&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If &lt;code&gt;new&lt;/code&gt; took a &lt;code&gt;&amp;amp;str&lt;/code&gt; instead of a &lt;code&gt;String&lt;/code&gt;, it could hide &lt;code&gt;String::from&lt;/code&gt; in
the implementation. However, passing in a &lt;code&gt;String&lt;/code&gt; would become less ergonomic,
and it would involve and additional heap allocation. Let&amp;rsquo;s see what that
looks like:&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// new function now looks like so&lt;/span&gt;
&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Token&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Token&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nf"&gt;Token&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;// &amp;amp;str can be passed seamlessly&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Token&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"abc123"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c"&gt;// Can still use a String, but it needs to be sliced, and&lt;/span&gt;
&lt;span class="c"&gt;// the new fn will copy it&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;secret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;secret_from_vault&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"api.example.io"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Token&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;secret&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;..&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt; &lt;span class="c"&gt;// inefficent!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is a way that &lt;code&gt;new&lt;/code&gt; can accept both forms with no allocation needed in the
case of a String.&lt;/p&gt;

&lt;h1 id="introducing-into"&gt;Introducing Into&lt;/h1&gt;

&lt;p&gt;The standard libary has a trait
&lt;a href="https://doc.rust-lang.org/std/convert/trait.Into.html"&gt;Into&lt;/a&gt; which will help
our &lt;code&gt;new&lt;/code&gt; problem. The trait definition looks like this:&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="n"&gt;Into&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;into&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;into&lt;/code&gt; function it defines is pretty straight-forward; it consumes self (the
thing implementing Into) and returns a &lt;code&gt;T&lt;/code&gt; (note the type parameter on the trait
definition). Here&amp;rsquo;s how it&amp;rsquo;s used:&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Token&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;/// Create a new token&lt;/span&gt;
    &lt;span class="c"&gt;///&lt;/span&gt;
    &lt;span class="c"&gt;/// Can be passed either a &amp;amp;str or String&lt;/span&gt;
    &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Token&lt;/span&gt;
        &lt;span class="n"&gt;where&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Into&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Token&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="nf"&gt;.into&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;// &amp;amp;str&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Token&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"abc123"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c"&gt;// String&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Token&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;secret_from_vault&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"api.example.io"&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s a lot going on here. First, the function now has a generic type
parameter, &lt;code&gt;S&lt;/code&gt;. The argument &lt;code&gt;raw&lt;/code&gt; has this type. The line reading &lt;code&gt;where S:
Into&amp;lt;String&amp;gt;&lt;/code&gt; limits the types of &lt;code&gt;S&lt;/code&gt; to &lt;em&gt;anything&lt;/em&gt; that implements
&lt;code&gt;Into&amp;lt;String&amp;gt;&lt;/code&gt;. Since the standard library already provides &lt;code&gt;Into&amp;lt;String&amp;gt;&lt;/code&gt; for
&lt;code&gt;&amp;amp;str&lt;/code&gt; and for &lt;code&gt;String&lt;/code&gt;, our use case is handled. &lt;sup&gt;&lt;a href="#1"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Although the ergonomics have been greatly improved, there&amp;rsquo;s still an issue with
this API. Passing a &lt;code&gt;&amp;amp;str&lt;/code&gt; to &lt;code&gt;new&lt;/code&gt; requires an allocation to store the value as
a &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id="cow-to-the-rescue"&gt;Cow to the rescue&lt;/h1&gt;

&lt;p&gt;The standard library has a type
&lt;a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"&gt;&lt;code&gt;std::borrow:Cow&lt;/code&gt;&lt;/a&gt; which
enables us to keep the ergonomics of the &lt;code&gt;Into&amp;lt;String&amp;gt;&lt;/code&gt; API while also allowing
for borrowed values like a &lt;code&gt;&amp;amp;str&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the scary-looking definition of &lt;code&gt;Cow&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;Cow&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;where&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ToOwned&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="err"&gt;?&lt;/span&gt;&lt;span class="n"&gt;Sized&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;Borrowed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="nf"&gt;Owned&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nn"&gt;B&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;Owned&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s break that down.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Cow&amp;lt;&amp;#39;a, B&amp;gt;&lt;/code&gt; has two generic parameters; a lifetime &lt;code&gt;&amp;#39;a&lt;/code&gt;, and some type &lt;code&gt;B&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; is constrained to &lt;code&gt;&amp;#39;a + ToOwned + ?Sized&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;#39;a&lt;/code&gt; - &lt;code&gt;B&lt;/code&gt; cannot contain a lifetime shorter than &lt;code&gt;&amp;#39;a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+ ToOwned&lt;/code&gt; - &lt;code&gt;B&lt;/code&gt; must implement &lt;code&gt;ToOwned&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+ ?Sized&lt;/code&gt; - The size of B can be unknown at compile time. This isn&amp;rsquo;t
relevant for our use case, but it means that trait objects may be used
with the Cow type.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;There&amp;rsquo;s two variants

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Borrowed(&amp;amp;&amp;#39;a B)&lt;/code&gt; - a reference to some object of type B. The lifetime of
this reference is the same as the lifetime bound.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Owned(B::Owned)&lt;/code&gt; - The &lt;code&gt;ToOwned&lt;/code&gt; trait has an associated type &lt;code&gt;Owned&lt;/code&gt;.
This variant holds that type.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We want to have a &lt;code&gt;Cow&amp;lt;&amp;#39;a, str&amp;gt;&lt;/code&gt;, which will look something like this after type
substitution.&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;Cow&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;Borrowed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="nf"&gt;Owned&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In short, &lt;code&gt;Cow&amp;lt;&amp;#39;a, str&amp;gt;&lt;/code&gt; will be either a &lt;code&gt;&amp;amp;str&lt;/code&gt; with the lifetime &lt;code&gt;&amp;#39;a&lt;/code&gt;, or it
will be a &lt;code&gt;String&lt;/code&gt; which is not bound by that lifetime. This sounds great for
the Token type! It will be able to hold either a &lt;code&gt;&amp;amp;str&lt;/code&gt; or a &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Token&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Cow&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Token&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Cow&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Token&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Token&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;// Create the tokens.&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Token&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nn"&gt;Cow&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;Borrowed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"abc123"&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;secret&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;secret_from_vault&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"api.example.io"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Token&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nn"&gt;Cow&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;Owned&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;secret&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Token can now be created with either an owned or a borrowed type, but we&amp;rsquo;ve
lost the API ergonomics! &lt;code&gt;Into&lt;/code&gt; can do the same thing for our &lt;code&gt;Cow&amp;lt;&amp;#39;a, str&amp;gt;&lt;/code&gt; as
it did for a simple &lt;code&gt;String&lt;/code&gt; earlier. The final Token implementation looks like
this:&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Token&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Cow&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Token&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Token&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="n"&gt;where&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Into&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Cow&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Token&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="nf"&gt;.into&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;// Create the tokens.&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Token&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"abc123"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Token&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;secret_from_vault&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"api.example.io"&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, a token can be created ergonomically from either a &lt;code&gt;&amp;amp;str&lt;/code&gt; or a &lt;code&gt;String&lt;/code&gt;.
The lifetime bound on &lt;code&gt;Token&lt;/code&gt; is no longer a problem for escaping stack frames
when created with a &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;&amp;amp;&amp;#39;static str&lt;/code&gt;; it can even be sent across
threads!&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"abc"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;token_owned&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Token&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;token_static&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Token&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"123"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="nn"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;spawn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;move&lt;/span&gt; &lt;span class="p"&gt;||&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"token_owned: {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;token_owned&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"token_static: {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;token_static&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;})&lt;/span&gt;&lt;span class="nf"&gt;.join&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trying to send a token with a non-&lt;code&gt;&amp;#39;static&lt;/code&gt; ref will fail.&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// Make a ref with non-'static lifetime&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"abc"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;..&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Token&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c"&gt;// This won't work&lt;/span&gt;
&lt;span class="nn"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;spawn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;move&lt;/span&gt; &lt;span class="p"&gt;||&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"token: {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;})&lt;/span&gt;&lt;span class="nf"&gt;.join&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Indeed, the above example fails with&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;error: `raw` does not live long enough
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;re hungry for more examples, please check out the &lt;a href="https://github.com/jwilm/pagerduty-rs"&gt;PagerDuty API
client&lt;/a&gt; which uses &lt;code&gt;Cow&lt;/code&gt; extensively.&lt;/p&gt;

&lt;p&gt;Thanks for reading!&lt;/p&gt;

&lt;h1 id="notes"&gt;Notes&lt;/h1&gt;

&lt;h2 id="1"&gt;1&lt;/h2&gt;

&lt;p&gt;If you were to go looking for the &lt;code&gt;Into&amp;lt;String&amp;gt;&lt;/code&gt; impl for &lt;code&gt;&amp;amp;str&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt;,
you wouldn&amp;rsquo;t find it. This is because there&amp;rsquo;s a generic implementation of Into
for types implementing From. It&amp;rsquo;s often said that &lt;code&gt;From&lt;/code&gt; implies &lt;code&gt;Into&lt;/code&gt;, and
it&amp;rsquo;s because of this blanket impl. The whole thing looks like this&lt;/p&gt;
&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;impl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Into&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;where&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;From&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;into&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nn"&gt;U&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
  <entry>
    <title>YouCompleteMe, Rust</title>
    <link rel="alternate" href="http://blog.url.com/youcompleteme-rust/"/>
    <id>http://blog.url.com/youcompleteme-rust/</id>
    <published>2016-01-07T16:00:00-08:00</published>
    <updated>2016-05-05T08:08:04-07:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a href="https://github.com/valloric/YouCompleteMe"&gt;YouCompleteMe&lt;/a&gt; now supports Rust auto-completion and GoTo. Rust semantic
analysis is provided by &lt;a href="https://github.com/jwilm/racerd"&gt;racerd&lt;/a&gt;, a JSON/HTTP server powered by &lt;a href="https://github.com/phildawes/racer"&gt;racer&lt;/a&gt;. YCM
with Rust provides a superior experience to current vim-racer, emacs-racer, and
other racer-based plugins.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://img.svbtle.com/xtrifoeons6nfa.gif"&gt;&lt;img alt="ycm_rust_launch.gif" src="https://d23f6h5jpj26xu.cloudfront.net/xtrifoeons6nfa_small.gif" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id="youcompleteme"&gt;YouCompleteMe&lt;/h1&gt;

&lt;p&gt;For the uninitiated, &lt;a href="https://github.com/valloric/YouCompleteMe"&gt;YouCompleteMe&lt;/a&gt; is a fast, fuzzy, as-you-type
code-completion engine built originally for Vim. YCM runs on Mac, Linux, and
Windows and includes completion engines for C/C++, ObjC, Python, C#, Go,
TypeScript, JavaScript, and now Rust. YCM additionally provides an identifier
based completion engine to supplement semantic completers and provide
completions for languages without native support.&lt;/p&gt;

&lt;p&gt;The YCM core, &lt;a href="https://github.com/valloric/ycmd"&gt;ycmd&lt;/a&gt;, exists &lt;a href="https://val.markovic.io/articles/youcompleteme-as-a-server"&gt;as an independent project&lt;/a&gt;;
clients for &lt;a href="https://github.com/valloric/YouCompleteMe"&gt;Vim&lt;/a&gt;, &lt;a href="https://github.com/abingham/emacs-ycmd"&gt;Emacs&lt;/a&gt;, and &lt;a href="https://atom.io/packages/you-complete-me"&gt;Atom&lt;/a&gt;
all share the same infrastructure. The complete list of known clients is found
in &lt;a href="https://github.com/Valloric/ycmd#known-ycmd-clients"&gt;the ycmd README&lt;/a&gt;. If a ycmd client does not exist for
&lt;code&gt;$EDITOR&lt;/code&gt;, integrating with ycmd is as simple as integrating with a REST API.
The &lt;a href="https://github.com/Valloric/ycmd/tree/master/examples"&gt;ycmd example client&lt;/a&gt; shows how it&amp;rsquo;s done.&lt;/p&gt;

&lt;h1 id="rust"&gt;Rust&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href="http://rust-lang.org"&gt;Rust&lt;/a&gt; is a systems programming language that runs
blazingly fast, prevents segfaults, and guarantees thread safety. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Support for Rust is now available in YCM. The result is a powerful development
environment providing completions and GoTo in your favorite editor. Examples
below assume your editor is Vim. For other editors, please reference their YCM
client.&lt;/p&gt;

&lt;h2 id="completions"&gt;Completions&lt;/h2&gt;

&lt;p&gt;Semantic completions in YCM are provided when a &lt;em&gt;semantic trigger&lt;/em&gt;, &lt;code&gt;.&lt;/code&gt;, or
&lt;code&gt;::&lt;/code&gt;, is detected. In the provided example, you can see a completion menu
immediately appear after typing &lt;code&gt;std::&lt;/code&gt;, &lt;code&gt;std::collections::&lt;/code&gt;, and &lt;code&gt;Vec::&lt;/code&gt;; no
hotkey was necessary. As you continue to type, YCM fuzzy-filters available
completions using your input to narrow the completion list.&lt;/p&gt;

&lt;h2 id="goto"&gt;GoTo&lt;/h2&gt;

&lt;p&gt;The YCM Rust Completer provides the &lt;code&gt;GoTo&lt;/code&gt; subcommand. &lt;code&gt;GoTo&lt;/code&gt; attempts to find
where the identifier under the cursor is defined. If successful, a buffer is
opened for the file containing the definition, and the cursor is placed on the
definition.&lt;/p&gt;

&lt;p&gt;The complete GoTo command in Vim is &lt;code&gt;:YcmCompleter GoTo&lt;/code&gt;, and I highly recommend
mapping it to some hotkey. Example:&lt;/p&gt;
&lt;pre class="highlight viml"&gt;&lt;code&gt;nnoremap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Leader&lt;span class="p"&gt;&amp;gt;]&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;YcmCompleter GoTo&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="ycm-configuration-vim"&gt;YCM Configuration (Vim)&lt;/h2&gt;

&lt;p&gt;Rust completions and GoTo from the current crate and its dependencies will be
available without any additional configuration. For completions in the standard
library, a single variable &lt;code&gt;g:ycm_rust_src_path&lt;/code&gt; must be defined in your .vimrc.&lt;/p&gt;
&lt;pre class="highlight viml"&gt;&lt;code&gt;&lt;span class="c"&gt;" Naturally, this needs to be set to wherever your rust&lt;/span&gt;
&lt;span class="c"&gt;" source tree resides.&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g:ycm_rust_src_path&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'/usr/local/rust/rustc-1.5.0/src'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="differences-from-vim-racer-emacs-racer-and-others"&gt;Differences from vim-racer, emacs-racer, and others&lt;/h1&gt;

&lt;p&gt;Since &lt;code&gt;racerd&lt;/code&gt;, and subsequently YCM&amp;rsquo;s Rust Completer are powered by &lt;code&gt;racer&lt;/code&gt;,
the same code-completion and find-definition features are available. The
addition of YCM to this equation provides a &lt;em&gt;massive&lt;/em&gt; quality-of-life
improvement over the existing plugins:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;No hotkey required for completions&lt;/li&gt;
&lt;li&gt;Fuzzy search of available completions&lt;/li&gt;
&lt;li&gt;Identifier-based completion engine to supplement rust completions&lt;/li&gt;
&lt;li&gt;Performance: Completions are cached within YCM, and latency with racerd is
typically only a few ms once files are cached from disk. This is discussed
more in the racerd section following.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id="racerd"&gt;racerd&lt;/h1&gt;

&lt;p&gt;&lt;a href="https://github.com/jwilm/racerd"&gt;racerd&lt;/a&gt; is suitable for providing completions and find-definition support for
&lt;em&gt;any&lt;/em&gt; Rust IDE and is not constrained to YCM. It provides several benefits over
integrating racer via the command line or with the racer &lt;code&gt;daemon&lt;/code&gt; flag.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Persistent file caching: When starting a new racer process for every
completion, or when running racer in daemon mode, the cache is thrown out
after each operation. Racerd keeps this cache between requests. This gives a
nice performance boost since files only need to be read from disk once.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Support for dirty buffers: &lt;a href="https://github.com/jwilm/racerd/blob/master/docs/API.md"&gt;Racerd&amp;rsquo;s JSON API&lt;/a&gt; supports a &lt;code&gt;buffers&lt;/code&gt; field -
a list of file paths (which need not exist) and associated contents which is
added to the racer cache before performing a query. This feature eliminates
the need for temporary files.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HTTP/JSON API: Very effective method for integrating a semantic completion
engine. Just about every language has a built-in or library for querying such
an API, and it is extremely performant on localhost (a few ms for completing
out of standard library). The process is long lived; there is no process
startup overhead for each query. Racerd also has &lt;a href="https://github.com/jwilm/racerd/blob/master/docs/API.md"&gt;extensive API
documentation&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id="giving-thanks"&gt;Giving Thanks&lt;/h1&gt;

&lt;p&gt;YouCompleteMe would not be the fantastic project it is, both technically and as
a positive open-source community, without the work of &lt;a href="https://github.com/valloric"&gt;@Valloric&lt;/a&gt; and the YCM
team &lt;a href="https://github.com/micbou"&gt;@micbou&lt;/a&gt;, &lt;a href="https://github.com/oblitum"&gt;@oblitum&lt;/a&gt;, &lt;a href="https://github.com/vheon"&gt;@vheon&lt;/a&gt;, and &lt;a href="https://github.com/puremourning"&gt;@puremourning&lt;/a&gt;. &lt;a href="https://github.com/jwilm/racerd"&gt;racerd&lt;/a&gt; and
YCM&amp;rsquo;s Rust completer would not have been possible without &lt;a href="https://github.com/phildawes"&gt;@phildawes&lt;/a&gt;&amp;rsquo;
fantastic &lt;a href="https://github.com/phildawes/racer"&gt;racer&lt;/a&gt; library. Thanks to &lt;a href="https://github.com/birkenfeld"&gt;@birkenfeld&lt;/a&gt; for his assistance
implementing some changes in racer to make racerd possible. Thanks to &lt;a href="https://github.com/reem"&gt;@reem&lt;/a&gt;
whom I pestered with far too many questions in #&lt;em&gt;iron&lt;/em&gt;. Finally, thanks to the
YCM team for reading drafts of this post.&lt;/p&gt;
</content>
  </entry>
</feed>
